import { AppUsageData } from '../types/AppUsageData';

function formatDuration(minutes: number): string {
  // Round to nearest minute to avoid decimal places
  minutes = Math.round(minutes);
  const hours = Math.floor(minutes / 60);
  const remainingMinutes = minutes % 60;
  return `${hours}h ${remainingMinutes}m`;
}

function generateBarGraph(value: number, maxValue: number, width: number = 30): string {
  const barWidth = Math.round((value / maxValue) * width);
  const bar = '█'.repeat(barWidth) + '░'.repeat(width - barWidth);
  return bar;
}

function getProductivityLabel(score: number): string {
  if (score >= 75) return 'Highly Productive';
  if (score >= 25) return 'Productive';
  if (score >= -25) return 'Neutral';
  if (score >= -75) return 'Distracting';
  return 'Highly Distracting';
}

function generateReportContent(
  appUsageData: AppUsageData[],
  totalScreenTime: number,
  productivityScore: number,
  frequency: string
): string {
  const date = new Date().toLocaleDateString();
  let content = `Screen Time Report - ${date}\n`;
  content += `${'═'.repeat(50)}\n\n`;
  
  // Report header
  content += `Report Type: ${frequency.charAt(0).toUpperCase() + frequency.slice(1)}\n`;
  content += `Total Screen Time: ${formatDuration(totalScreenTime)}\n`;
  
  // Productivity score with visual indicator
  const productivityBar = generateBarGraph(productivityScore + 100, 200, 20);
  content += '\nProductivity Score:\n';
  content += `${productivityScore}% - ${getProductivityLabel(productivityScore)}\n`;
  content += `${productivityBar} \n\n`;
  
  content += 'Application Usage Summary\n';
  content += '╔' + '═'.repeat(48) + '╗\n\n';
  
  // Group apps by category
  const categoryMap = new Map<string, AppUsageData[]>();
  appUsageData.forEach(app => {
    const category = app.category || 'Other';
    if (!categoryMap.has(category)) {
      categoryMap.set(category, []);
    }
    categoryMap.get(category)?.push(app);
  });

  // Sort categories by total time
  const sortedCategories = Array.from(categoryMap.entries()).sort((a, b) => {
    const aTime = a[1].reduce((sum, app) => sum + app.time, 0);
    const bTime = b[1].reduce((sum, app) => sum + app.time, 0);
    return bTime - aTime;
  });

  // Find maximum category time for graph scaling
  const maxCategoryTime = Math.max(...sortedCategories.map(([_, apps]) => 
    apps.reduce((sum, app) => sum + app.time, 0)
  ));

  // Category distribution with bar graphs
  sortedCategories.forEach(([category, apps]) => {
    const categoryTime = apps.reduce((sum, app) => sum + app.time, 0);
    const percentage = Math.round((categoryTime / totalScreenTime) * 100);
    const bar = generateBarGraph(categoryTime, maxCategoryTime);
    
    content += `${category}\n`;
    content += `${bar} ${formatDuration(categoryTime)} (${percentage}%)\n\n`;
    
    // Top 3 apps in category
    const topApps = apps
      .sort((a, b) => b.time - a.time)
      .slice(0, 3);
    
    topApps.forEach(app => {
      const appPercentage = Math.round((app.time / categoryTime) * 100);
      const appBar = generateBarGraph(app.time, categoryTime, 20);
      content += `  ├─ ${app.name}\n`;
      content += `  │  ${appBar} ${formatDuration(app.time)} (${appPercentage}%)\n`;
    });
    
    if (apps.length > 3) {
      const otherApps = apps.length - 3;
      content += `  └─ and ${otherApps} more app${otherApps > 1 ? 's' : ''}\n`;
    }
    content += '\n';
  });

  // Daily timeline (if data has timestamps)
  const appsWithTimestamps = appUsageData.filter(app => app.lastUsed);
  if (appsWithTimestamps.length > 0) {
    content += '\nDaily Activity Timeline\n';
    content += '╔' + '═'.repeat(48) + '╗\n\n';
    
    // Create 6 time blocks (4-hour intervals)
    const timeBlocks = Array(6).fill(0);
    appsWithTimestamps.forEach(app => {
      if (app.lastUsed) {
        const hour = new Date(app.lastUsed).getHours();
        const blockIndex = Math.floor(hour / 4);
        timeBlocks[blockIndex] += app.time;
      }
    });
    
    const maxBlockTime = Math.max(...timeBlocks);
    const timeRanges = [
      '00:00-04:00', '04:00-08:00', '08:00-12:00',
      '12:00-16:00', '16:00-20:00', '20:00-24:00'
    ];
    
    timeBlocks.forEach((time, index) => {
      if (time > 0) {
        const bar = generateBarGraph(time, maxBlockTime, 20);
        content += `${timeRanges[index]}\n`;
        content += `${bar} ${formatDuration(time)}\n\n`;
      }
    });
  }

  content += '\nThis report was generated by Screen Time Reminder\n';
  content += '╚' + '═'.repeat(48) + '╝\n';
  
  return content;
}

export function sendEmailReport(
  appUsageData: AppUsageData[],
  totalScreenTime: number,
  productivityScore: number,
  toEmail: string,
  frequency: string
): void {
  try {
    const subject = `Screen Time Report - ${new Date().toLocaleDateString()}`;
    const body = generateReportContent(appUsageData, totalScreenTime, productivityScore, frequency);
    
    // Create mailto URL
    const mailtoUrl = `mailto:${encodeURIComponent(toEmail)}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
    
    // Open default email client
    window.location.href = mailtoUrl;
  } catch (error) {
    console.error('Error opening email client:', error);
    throw error;
  }
}

export function validateEmailSettings(email: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
} 